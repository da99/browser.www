
external NaN, TypeError, Error, process, require, window;

/* process.stdout.write("."); */
import DA_STANDARD.SPECS;
import System.Console;
import System;

module DA_STANDARD.COMMON
{

  string[] keys(v) {
    string[] arr = [];
    for (string x in v) {
      if (v.hasOwnProperty(x))
        arr.push(x);
    }
    return arr;
  }

  bool is_positive(v) {
    return typeof v === 'number' && is_finite(v) && v > 0;
  }

  bool is_finite(v) {
    return (typeof v === 'number') && (v !== NaN);
  }

  bool is_plain_object(v) {
    return typeof(v) === "object" && v.constructor === {}.constructor;
  }

  bool is_object(v) {
    return typeof(v) === "object";
  }

  function is_string(v) {
    return typeof v === "string";
  }

  function is_num(v) {
    return typeof v === 'number' && v !== NaN;
  }

  function is_boolean(v) {
    return typeof v === 'boolean';
  }

  bool is_true(v) {
    return v === true;
  }

  bool is_array(v) {
    var a = [];
    return typeof(v) == "object" && v.constructor === a.constructor;
  }

  bool is_function(v) {
    return typeof(v) === "function";
  }

  bool is_regexp(val) {
    return(val instanceof RegExp);
  }

  function is_null_specs() {
    should_eq(true,  bool () { return is_null(null); });
    should_eq(false, bool () { return is_null(undefined); });
  }

  bool is_null(v) {
    return v === null || typeof(v) === "null";
  }

  function is_undefined_specs() {
    should_eq(true,  bool () { return is_undefined(undefined); });
    should_eq(false, bool () { return is_undefined(null); });
  }

  bool is_undefined(v) {
    return v === undefined || typeof(v) === "undefined";
  }

  function is_enumerable_specs() {
    should_eq(true,  bool () { return is_enumerable(["a"]); });
    should_eq(true,  bool () { return is_enumerable({"a": "b"}); });
    should_eq(false, bool () { return is_enumerable("a"); });
  }

  function is_enumerable(v) {
    return is_string(v) ||
      is_array(v)         ||
      is_plain_object(v)  ||
      is_arguments(v) ||
      (is_something(v) && is_finite(v.length));
  }


  function is_error_specs() {
    should_eq(true,  bool () { return is_error(new Error('anything')); });
    should_eq(false, bool () { return is_error('anything'); });
    should_eq(true,  bool () { return is_error(new Error('meh')); });
    should_eq(true,  bool () { return is_error(new TypeError('meow')); });
    should_eq(false, bool () { return is_error({stack: "", message: ""}); });
  }

  function is_error(v) {
    return is_object(v) && (
      v.constructor === Error ||
      (!is_plain_object(v) && is_string(v.stack) && is_string(v.message))
    );
  }

  function is_nothing_specs() {
    should_eq(true,  bool () { return is_nothing(null); });
    should_eq(true,  bool () { return is_nothing(undefined); });
    should_eq(false, bool () { return is_nothing([]); });
    should_eq(false, bool () { return is_nothing({}); });
    should_eq(false, bool () { return is_nothing({a: "c"}); });
  }

  bool is_nothing(v) {
    return v === null || v === undefined;
  }

  bool is_null_or_undefined(v) {
    return v === null || v === undefined;
  }

  function is_empty_specs() {
    should_eq(true,  bool () { return is_empty([]); });
    should_eq(true,  bool () { return is_empty({}); });
    should_eq(true,  bool () { return is_empty(""); });
    should_eq(false, bool () { return is_empty({a: "c"}); });
    should_eq(false, bool () { return is_empty([1]); });
    should_eq(false, bool () { return is_empty("a"); });
    should_eq(true,  bool () { return is_empty(return_arguments()); });
    should_eq(false, bool () { return is_empty(return_arguments(1,2,3)); });
    should_eq(true,  bool () { return is_empty(""); });
    should_eq(false, bool () { return is_empty("a"); });
    should_eq(false, bool () { return is_empty("  "); });
  }

  bool is_empty(string str) {
    return str.length === 0;
  }

  bool is_empty(v) {
    if (v && is_finite(v.length))
      return v.length === 0;

    if (is_plain_object(v))
      return keys(v).length === 0;

    if (is_arguments(v))
      return v.length === 0;

    throw new Error("Invalid value for is_empty: " + to_string(v));
  } // === func

  function is_something_specs() {
    should_eq(false, bool () { return is_something(null); });
    should_eq(false, bool () { return is_something(undefined); });
    should_eq(true,  bool () { return is_something([]); });
    should_eq(true,  bool () { return is_something({}); });
    should_eq(true,  bool () { return is_something({a: "c"}); });
  }

  function is_something(v) {

    if (arguments.length !== 1)
      throw new Error("arguments.length !== 1: " + to_string(v));
    return v !== null && v !== undefined;
  }

  string inspect(arg) {
    return to_string(arg);
  }

  function to_string_specs() {
    should_eq('null',              string () { return to_string(null); });
    should_eq('undefined',         string () { return to_string(undefined); });
    should_eq('[1]',               string () { return to_string([1]); });
    should_eq('"yo yo"',           string () { return to_string('yo yo'); });
    should_eq('{"a":"b","c":"d"}', string () { return to_string({a:'b', c:'d'}); });
  }

  string to_string(string str) {
    return '"' + str + '"';
  }

  string to_string(bool b) {
    if (b === false)     return 'false';
    if (b === true)      return 'true';
  }

  string to_string(arg) {
    if (arg === null)      return 'null';
    if (arg === undefined) return 'undefined';

    if (is_function(arg))
      return arg.toString().replace("function (){return(", "").replace(/\)?;\}$/, '');

    if (is_function(arg))
      return (arg.name) ? arg.name + ' (function)' : arg.toString();

    if (is_error(arg))
      return '[Error] ' + to_string(arg.message);


    if (arg === "object" ) {
      if (is_array(arg)) {
        string[] fin = ["["];
        foreach ( var x in arg ) {
          fin.push(to_string(x));
        }
        fin.push("]");
        return fin.join(", ");
      }

      string[] fin = ["{"];
      for(var x in arg) {
        if (arg.hasOwnProperty(x)) {
          fin.push(to_string(arg[x]));
        }
      }
      fin.push("}");
      return fin.join(", ");
    }

    if ( is_arguments(arg) )
      return to_string(to_array(arg));

    var _inspect = (typeof window == "undefined") ? require('util').inspect : function (v) { return "" + v; };
    return _inspect(arg);
  } // === string to_string

  function is_arguments_specs() {
    should_eq(true,  bool () { return is_arguments(return_arguments()); });
    should_eq(false, bool () { return is_arguments([]); });
    should_eq(false, bool () { return is_arguments({}); });
  }

  function is_arguments(v) {
    return is_something(v) && v.constructor === arguments.constructor;
  }


  /* function key_to_bool_specs() { */
  /*   should_eq(key_to_bool, ['time', {time: 'morning'}], true); // it 'returns true if key is "truthy"' */
  /*   should_eq(key_to_bool, ['!time', {time: false}], true); // it 'returns true if: !key , key is !truthy' */
  /*   should_eq(key_to_bool, ['!first.second.third', {first: {second: { third: true}}}], true); // it 'handles nested keys' */
  /*   should_eq(key_to_bool, ['!!!first', {first: false}], true); // it 'handles multiple exclamation marks' */
  /*   should_eq(key_to_bool, ['first', {}], undefined); // it 'returns undefined if one non-nested key is specified, but not found' */
  /*   should_eq(key_to_bool, ['is_factor', {is_factor: true}], true); */
  /*   should_eq(key_to_bool, ['!is_factor', {is_factor: false}], true); */
  /*   should_eq(key_to_bool, ['is_factor', {is_ruby: false}], undefined); */
  /*   should_eq(key_to_bool, ['is_happy', {is_happy: true}], true); */
  /*   should_eq(key_to_bool, ['!is_happy', {is_happy: true}], false); */
  /*   should_eq(key_to_bool, ['is_happy',  {is_happy: false}], false); */
  /*   should_eq(key_to_bool, ['!is_happy', {is_happy: false}], true); */
  /*   should_eq(key_to_bool, [['is_factor'], {}], new Error("[\"is_factor\"] should be: is_string (function)")); */
  /* } */

  /* function key_to_bool(raw_key, data) { */

  /*   var FRONT_BANGS = /^\!+/; */

  /*   var key = reduce( */
  /*     raw_key, */
  /*     be(is_string), */
  /*     _.trim, */
  /*     be(not(is_empty)) */
  /*   ); */

  /*   var bang_match = key.match(FRONT_BANGS); */
  /*   var dots       = ( bang_match ? key.replace(bang_match[0], '') : key ).split('.'); */
  /*   var keys       = _.map( dots, _.trim ); */

  /*   var current = data; */
  /*   var ans  = false; */

  /*   _.find(keys, function (key) { */
  /*     if (_.has(current, key)) { */
  /*       current = data[key]; */
  /*       ans = !!current; */
  /*     } else { */
  /*       ans = undefined; */
  /*     } */

  /*     return !ans; */
  /*   }); */

  /*   if (ans === undefined) */
  /*     return ans; */

  /*   if (bang_match) { */
  /*     _.times(bang_match[0].length, function () { */
  /*       ans = !ans; */
  /*     }); */
  /*   } */

  /*   return ans; */
  /* } // === func */

  /* bool is_function(v) { */
  /*   return typeof v === 'function'; */
  /* } */

  /* function set_function_string_name(f, args) { */
  /*   if (f.to_string_name) */
  /*     throw new Error('.to_string_name alread set: ' + to_string(f.to_string_name)); */
  /*   f.to_string_name = function_sig(f, args); */
  /*   return f; */
  /* } */

  /* string function_sig(f, args) { */
  /*   return function_to_name(f) + '(' + _.map(args, to_string).join(',')  + ')'; */
  /* } */

  /* function function_to_name_specs() { */
  /*   should_eq(function_to_name, ["function my_name() {}"], "my_name"); */
  /* } */

  /* function function_to_name(f) { */
  /*   var WHITESPACE = /\s+/g; */
  /*   return f.to_string_name || f.toString().split('(')[0].split(WHITESPACE)[1] || f.toString(); */
  /* } */

  /* function to_function_string(f, args) { */
  /*   return function_to_name(f) + '(' + _.map(args, to_string).join(', ') + ')'; */
  /* } */

  /* bool all(_funcs) { */
  /*   var _and = and.apply(null, arguments); */
  /*   return function (arr) { */
  /*     for(var i = 0; i < length(arr); i++){ */
  /*       if (!_and(arr[i])) */
  /*         return false; */
  /*     } */
  /*     return true; */
  /*   }; */
  /* } */

  /* function own_property_specs() { */
  /*   should_eq(3, function own_property_returns_own_property() { */
  /*     return own_property('num')({num: 3}); */
  /*   }); */
  /*   should_eq(own_property('num'), [{n:4}], new Error('Key not found: "num" in {"n":4}')); */
  /* } */

  /* function own_property(name) { */

  /*   return function _own_property_(o) { */
  /*     if (!o.hasOwnProperty(name)) */
  /*       throw new Error('Key not found: ' + to_string(name) + ' in ' + to_string(o)); */
  /*     return o[name]; */
  /*   }; */
  /* } // === func own_property */

  /* function msg_match_specs() { */
  /*   should_eq(msg_match, [1,1], true); */
  /*   should_eq(msg_match, ["a", "a"], true); */
  /*   should_eq(msg_match, [[1],[1]], true); */
  /*   should_eq(msg_match, [[1,[2]],[1,[2]]], true); */
  /*   should_eq(msg_match, [{a:"b"}, {a:"b",c:"d"}], true); */
  /*   should_eq(msg_match, [{a:is_string}, {a:"b"}], true); */
  /*   should_eq(msg_match, [{}, {a:"b"}], false); */
  /*   should_eq(msg_match, [{}, {}], true); */
  /*   should_eq(msg_match, [[], []], true); */
  /* } */

  /* bool msg_match(pattern, msg) { */

  /*   if (_.isEqual(pattern, msg)) */
  /*     return true; */

  /*   if (is_plain_object(pattern) && is_plain_object(msg)) { */
  /*     if (is_empty(pattern) !== is_empty(msg)) */
  /*       return false; */

  /*     return !_.find(_.keys(pattern), function (key) { */
  /*       var target = pattern[key]; */
  /*       if (msg[key] === target) */
  /*         return !true; */
  /*       if (is_function(target)) */
  /*         return !be(is_boolean, target(msg[key])); */
  /*       return !false; */
  /*     }); */
  /*   } */

  /*   return false; */
  /* } */

  /* function copy_value_specs() { */
  /* should_eq({a:{b:"c"}, b:true}, function () { // Does not alter orig. */
  /*   var orig = {a:{b:"c"}, b:true}; */
  /*   var copy = copy_value(orig); */
  /*   copy.a.b = "1"; */
  /*   return orig; */
  /* }); */

  /* should_eq(copy_value, [[1, copy_value], is_function], [1, copy_value]); */
  /* } */

  /* function copy_value(v) { */
  /*   var allow_these = []; */

  /*   if (length(arguments) < 2) { */
  /*     arguments_are(arguments, is_something); */
  /*   } else { */
  /*     allow_these = _.toArray(arguments).slice(1); */
  /*   } */

  /*   var type = typeof v; */
  /*   if (type === 'string' || type === 'number' || is_boolean(v)) */
  /*     return v; */

  /*   if (is_array(v)) */
  /*     return _.map(v, function (new_v) { return copy_value.apply(null, [new_v].concat(allow_these)); }); */

  /*   if (is_plain_object(v)) */
  /*     return reduce_eachs({}, v, function (acc, kx, x) { */
  /*       acc[kx] = copy_value.apply(null, [x].concat(allow_these)); */
  /*       return acc; */
  /*     }); */

  /*   var return_val = _.find(allow_these, function (f) { return f(v); }); */
  /*   if (return_val) */
  /*     return v; */

  /*   return v; */
  /*   // throw new Error('Value can\'t be copied: ' + to_string(v)); */
  /* } */

  /* function has_length_specs() { */
  /*   should_eq(true, function has_length_returns_function() { */
  /*     return is_function(has_length(1)); */
  /*   }); */

  /*   should_eq(true, function has_length_returns_function_comparing_length() { */
  /*     return has_length(1)([1]); */
  /*   }); */

  /*   should_eq(true, function has_length_returns_function_comparing_length_of_function() { */
  /*     return has_length(2)(function (a,b) {}); */
  /*   }); */

  /*   should_eq( */
  /*     function () { // returns function that returns false on length mismatch */
  /*       return has_length(3)([1,2]); */
  /*     }, */
  /*     [], */
  /*     new Error("[1, 2].length !== 3") */
  /*   ); */
  /* } */

  /* function has_length(num) { */
  /*   return function _has_length_(val) { */
  /*     arguments_are(arguments, is_something); */
  /*     if (val.length === num) */
  /*       return true; */
  /*     throw new Error(to_string(val) + '.length !== ' + to_string(num)); */
  /*   }; */
  /* } */

  /* function is_specs() { */
  /*   should_eq(true,  function () { return is(5)(5); }); */
  /*   should_eq(false, function () { return is("a")("b"); }); */
  /* } */

  /* function is(target) { */
  /*   return function (val) { return val === target; }; */
  /* } */

  /* function keys_or_indexes(v) { */
  /*   if (is_plain_object(v)) */
  /*     return _.keys(v); */

  /*   var a = []; */
  /*   for(var i = 0; i < v.length; i++) { */
  /*     a[i] = i; */
  /*   } */
  /*   return a; */
  /* } */

  /* function to_value_specs() { */
  /*   should_eq('"4"', function to_value_returns_a_value() { */
  /*     return to_value(4, to_string, to_string); */
  /*   }); */

  /*   should_eq(5, function to_value_returns_first_value_if_no_funcs() { */
  /*     return to_value(5); */
  /*   }); */
  /* } */



  function return_arguments(...args) { return args; }
  function to_arguments() { return arguments; }

  function to_array_specs() {
    should_eq([1,2,3], function () { return to_array([1,2,3]); });
    should_eq([1,2,3], function () { return to_array(return_arguments(1,2,3)); });
  }

  function to_array(val) {
    if (!is_array(val) && val.constructor != arguments.constructor)
      throw new Error("Invalid value for to_array: " + to_string(val));

    var arr = [];
    int len = val.length;
    for (int i = 0; i < len; i++) {
      arr.push(val[i]);
    }
    return arr;
  } // === func

  /* function to_slot(func, _args) { */

  /*   var ARGS = to_array(arguments).slice(1); */

  /*   return function _to_slot_() { */

  /*     var MIDDLE_ARGS = to_array(arguments); */
  /*     var FIN_ARGS = reduce_eachs([], ARGS, function (array, _i, x) { */
  /*       if (x !== '{{_}}') { */
  /*         array.push(x); */
  /*         return array; */
  /*       } */

  /*       if (is_empty(MIDDLE_ARGS)) */
  /*         throw new Error("Not enough arguments for: " + to_string(func) + " args: " + length(MIDDLE_ARGS) + " != " + length(ARGS)); */

  /*       array.push(MIDDLE_ARGS.shift()); */

  /*       return array; */
  /*     }); */

  /*     if (!is_empty(MIDDLE_ARGS)) */
  /*       throw new Error("Extra args for : " + to_string(func) + " extra: " + length(MIDDLE_ARGS)); */

  /*     return func.apply(null, FIN_ARGS); */
  /*   }; // === return */

  /* } // === function to_slot */

  // Removes begining slash, if any.
  string to_var_name(string val) {
    return to_var_name(val, "_");
  }

  string to_var_name(string val, string delim) {
    return val.replace(/^[\/]+/, "").replace(/[^a-zA-Z-0-9\_\-]+/g, delim);
  }

  bool do_it(int num, func) {
    for (var i = 0; i < num; i++) {
      func();
    }
    return true;
  }

} // === module DA_STANDARD.COMMON

