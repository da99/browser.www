
external Error, setTimeout, window;
import System.Console;
import DA_STANDARD.COMMON;

module DA_STANDARD.SPECS
{

  class THE_SPECS {
    public static var fail_list = [];
    public static int pass_count = 0;
    public static int wait_count = 0;
    public static var spec_list = [];

    public static int timeout(bool() cond, void() f) {
      THE_SPECS.wait_count += 1;
      int max = 5;
      int count = 0;

      void reloop() {
        count += 1;
        if (count >= max) {
          THE_SPECS.wait_count -= 1;
          failed("Gave up waiting for test: " + COMMON.to_string(cond), true, cond());
          return;
        }

        if (cond() === true) {
          THE_SPECS.wait_count -= 1;
          f();
          return;
        }

        setTimeout(reloop, 150);
      }
      reloop();

      return THE_SPECS.wait_count;
    }

    public static int timeout(void() f) {
      return THE_SPECS.timeout(f, 5000);
    }

    public static int timeout(void() f, int interval) {
      THE_SPECS.wait_count += 1;
      setTimeout(void () { THE_SPECS.wait_count -= 1; f(); }, interval);
      return THE_SPECS.wait_count;
    }

    public static void push(string name, void() f) {
      spec_list.push([name, f]);
    }

    public static void run(void() passed, void() they_failed) {
      while (THE_SPECS.spec_list.length > 0 && THE_SPECS.wait_count == 0) {
        var pair = THE_SPECS.spec_list.shift();
        Console.log("=== " + pair[0] + " ===");
        pair[1]();
        Console.log("");
      }

      if (THE_SPECS.wait_count == 0) {
        if (THE_SPECS.fail_list.length > 0) {
          they_failed();
          throw new Error("Specs failed: \n" + THE_SPECS.fail_list.join("\n"));
        } else
          passed();
      } else {
        setTimeout(void () { THE_SPECS.run(passed, they_failed); }, 1000);
      }
    } // === void run(f)

  } // === class THE_SPECS

  bool arrays_are_equal(a1, a2) {
    int len_1 = a1.length;
    int len_2 = a2.length;
    if (len_1 !== len_2)
      return false;
    for (int i = 0 ; i < len_1 ; i++) {
      if (a1[i] !== a2[i])
        return false;
    }
    return true;
  }

  void should_eq(expected, func_or_other) {
    var actual = undefined;
    if (is_function(func_or_other)) {
      actual = func_or_other();
    } else {
      actual = func_or_other;
    }

    if (
        (actual != expected) &&
        !(is_array(expected) && is_array(actual) && arrays_are_equal(expected, actual))
       ) {
      failed(to_string(func_or_other), to_string(expected), to_string(actual));
    }

    Console.log("Pass: " + to_string(expected) + " == " + to_string(func_or_other) );
  }

  void failed(string msg, expected, actual) {
    string new_msg = msg + " EXPECTED: " + expected + " ACTUAL: " + actual;
    if (typeof window === 'undefined')
      throw new Error("Failed: " + to_string(expected) + " !== " + to_string(actual));
    else
      THE_SPECS.fail_list.push(new_msg);
  }

  void should_eq(expected, func, ...args) {
    var actual = undefined;

    if (args.length == 0) {
      actual = func();
    } else {
      actual = func.apply(null, args);
    }

    if (actual != expected) {
      failed(to_string(func) + " args: " + to_string(args), to_string(expected), to_string(actual));
    }

    Console.log("Pass: " + to_string(expected) + " == " + func.name + to_string(args));
  }

  void spec(f, args, expected) {
    var actual = f.apply(args);
    if (actual != expected) {
      failed(f + "(" + args + ")", expected, actual);
    }
    Console.log("Pass: " + f + "(" + args + ")");
  }

  class THE_STAGE {
    public static void reset(string html) {
      window.document.querySelector("#THE_STAGE").innerHTML = html;
    }
  } // === class THE_STAGE

  /* function spec_next(specs) { */

  /*   function to_string(v) { */
  /*     return "" + v; */
  /*   } */

  /*   be(is_specs, specs); */

  /*   if (specs.i === 'init') { */
  /*       specs.i = 0; */
  /*   } else { */
  /*     if (specs.dones[specs.i] !== true) */
  /*       throw new Error("Spec did not finish: " + to_string(specs.list[specs.i])); */
  /*     specs.i = specs.i + 1; */
  /*   } */

  /*   var i    = specs.i; */
  /*   var list = specs.list; */
  /*   var func = list[i]; */

  /*   // === Are all specs finished? */
  /*   if (!func && i >= length(specs.list)) { */
  /*     specs.total = i; */
  /*     if (specs.total !== specs.list.length) */
  /*       throw new Error('Not all specs finished: ' + to_string(specs.total) + ' !== ' + to_string(specs.list.length)); */
  /*     specs.on_finish(specs); */
  /*     return length(specs.list); */
  /*   } */

  /*   // === Function was found? */
  /*   if (!func) { */
  /*     throw new Error('Spec not found: ' + to_string(i)); */
  /*   } */

  /*   // === Async? */
  /*   if (length(func) === 1 ) { */
  /*     setTimeout(function () { */
  /*       if (!specs.dones[i]) */
  /*         throw new Error("Spec did not finish in time: " + to_string(func)); */
  /*     }, 2500); */
  /*     func(function () { */
  /*       specs.dones[i] = true; */
  /*       spec_next(specs); */
  /*     }); */
  /*     return false; */
  /*   } */

  /*   // === Regular spec, non-asyc? */
  /*   if (length(func) === 0) { */
  /*     func(); */
  /*     specs.dones[i] = true; */
  /*     return spec_next(specs); */
  /*   } */

  /*   throw new Error('Function has invalid arguments: ' + to_string(func)); */
  /* } */

  /* void is_specs(specs) { */
  /*   var is_valid_specs_i = or(is('init'), is(0), is_positive); */

  /*   be(is_plain_object,  specs); */
  /*   be(not(is_empty),    specs.list); */
  /*   be(is_valid_specs_i, specs.i); */
  /*   be(is_plain_object,  specs.dones); */
  /*   return true; */
  /* } */

  /* // Specification function: */
  /* // Accepts: */
  /* //   string : 'reset'  => Reset dom for next test. */
  /* function spec_dom(cmd) { */

  /*   switch (cmd) { */
  /*     case 'reset': */
  /*       var stage = $('#Spec_Stage'); */
  /*       if (stage.length === 0) */
  /*         $('body').prepend('<div id="Spec_Stage"></div>'); */
  /*       else */
  /*         stage.empty(); */
  /*       break; */

  /*     default: */
  /*       if (arguments.length !== 0) */
  /*       throw new Error("Unknown value: " + to_string(arguments)); */
  /*   } // === switch cmd */

  /*   return $('#Spec_Stage'); */
  /* } */

  /* function spec_start() { */
  /* // === Expect: */
  /* // spec(my_func,             ["my args"],           "my expected value"); */
  /* // spec("my expected value", function my_custom_spec() { */
  /* //   return "a value"; */
  /* // }); */
  /* // */
  /* // === Throws: */
  /* // spec(my_func, ["my args"], new Error("my expected thrown error")); */
  /* // spec( */
  /* //   new Error("my expected thrown error"), */
  /* //   function my_custom_spec() { */
  /* //     throw new Error("something"); */
  /* //   } */
  /* // ); */
  /* // */
  /* // === Run specs: */
  /* // spec('send message'); */
  /* // spec(function (msg) { */
  /* //  log('Finished specs: ' + msg.total); */
  /* // }); */
  /* // */
  /* // === Used by other functions to continue running specs: */
  /* // spec({ */
  /* //    list: [], */
  /* //    i:"init"|0|positive, */
  /* //    on_finish: my_callback */
  /* // }); */
  /* // */


  /* // === Is there a specific spec to run? */
  /* (function () { */
  /*   if (typeof window === 'undefined') */
  /*     return; */
  /*   var href = window.location.href; */
  /*   var target = _.trim(href.split('?').pop() || ''); */
  /*   if (!is_empty(target) && target !== href  && target !== function_to_name("str_or_func")) */
  /*     return false; */

  /*   // === Reset DOM: */
  /*   spec_dom('reset'); */
  /*   spec.target = target; */
  /* })(); */
  /* } */

  /* function spec() { */

  /*   var is_allowed = ( */
  /*     ( typeof(window) !== 'undefined' && $('#Spec_Stage').length === 1) || */
  /*       ( typeof(process) !== 'undefined' && process.argv[2] === 'test') */
  /*   ); */

  /*   if (!is_allowed) */
  /*     return; */

  /*   var args = _.toArray(arguments); */

  /*   if (length(args) !== 1) { */
  /*     return App('push into or create', 'specs', args); */
  /*   } // === switch */

  /*   if (args[0] !== 'run' && !is_function(args[0])) */
  /*     throw new Error('Unknown value: ' + to_string(args[0])); */

  /*   App('create or ignore', 'spec on finishs', []); */
  /*   App('create or ignore', 'specs done', []); */
  /*   var specs = App('read or create', 'specs', []); */
  /*   var i     = App('read or create', 'spec.index', 0); */

  /*   if (is_empty(specs)) */
  /*     throw new Error('No specs found.'); */

  /*   if (is_function(arguments[0])) */
  /*     App('push into', 'spec on finishs', arguments[0]); */

  /*   while (i < specs.length) { */
  /*     if (run_spec(i, specs[i]) === 'wait') */
  /*       return 'wait'; */
  /*     i = App('read', 'spec.index'); */
  /*   } */

  /*   var passed = App('read', 'spec.index'); */
  /*   if (specs.length < passed) */
  /*     throw new Error("Total specs: " + specs.length + " != Passed specs: " + passed); */

  /*   var on_fins = App('read', 'spec on finishs'); */
  /*   if (is_empty(on_fins)) { */
  /*     on_fins.push(spec.default_msg); */
  /*   } */

  /*   var msg = {total: specs.length}; */
  /*   for (var func_i = 0; func_i < on_fins.length; func_i++) */
  /*     on_fins[func_i](msg); */

  /*   return 'finish'; */

  /*   function actual_equals_expect(actual, expect) { */
  /*     if (actual === expect) */
  /*       return true; */

  /*     if (is_string(actual) && is_regexp(expect) && actual.match(expect)) */
  /*       return true; */

  /*     if (actual && actual.constructor === Error && expect && expect.constructor && actual.message === expect.message) */
  /*       return true; */

  /*     if (actual && actual.constructor === Error && is_regexp(expect) && actual.message.match(expect)) */
  /*       return true; */

  /*     return false; */
  /*   } */

  /*   function run_spec(index, raw_spec) { */

  /*     var f, args_, expect, actual; */

  /*     if (raw_spec.length === 2 && is_function(raw_spec[1])) { */
  /*         f      = raw_spec[1]; */
  /*         args_  = (length(f) > 0) ? [compare_actual] : []; */
  /*         expect = raw_spec[0]; */
  /*     } else { */
  /*       if (raw_spec.length === 3 && is_function(raw_spec[0])) { */
  /*         f      = raw_spec[0]; */
  /*         args_  = raw_spec[1]; */
  /*         expect = raw_spec[2]; */
  /*       } else { */
  /*         throw new Error("Invalid spec: " + to_string(raw_spec)); */
  /*       } */
  /*     } */

  /*     // === Handle async specs: */
  /*     if (args_[0] === compare_actual) { */
  /*       f.apply(null, args_); */
  /*       wait_max(3, function () { */
  /*         if (!_.includes(App('read', 'specs done'), index)) */
  /*           return false; */
  /*         spec('run'); */
  /*         return true; */
  /*       }); */
  /*       return "wait"; */
  /*     } // === if ======================= */

  /*     try { */
  /*       actual = f.apply(null, args_); */
  /*     } catch (e) { */
  /*       actual = e; */
  /*     } */
  /*     compare_actual(actual); */
  /*     return true; */

  /*     function compare_actual(actual_) { */

  /*       var sig = to_function_string(f, args); */
  /*       var msg_ = ""; */
  /*       if (actual_ === expect) */
  /*         msg_ = to_string(actual_) + ' === ' + to_string(expect); */
  /*       else */
  /*         msg_ = to_string(actual_) + ' !== ' + to_string(expect); */

  /*       if (!actual_equals_expect(actual_, expect)) { */

  /*         if (is_error(actual_)) { */
  /*           console.error("!!! Failed w/ unexpected error: " + sig); */
  /*           throw actual_; */
  /*         } */

  /*         log(f, args, expect, actual_); */
  /*         throw new Error("!!! Failed: " + sig + ' -> ' + msg_ ); */
  /*       } */

  /*       log('=== Passed: ' + sig + ' -> ' + msg_); */

  /*       App('+1', 'spec.index'); */
  /*       App('push into', 'specs done', index); */
  /*     } // === compare_actual */
  /*   } // === function regular_spec */


} // === DA_STANDARD.SPECS
